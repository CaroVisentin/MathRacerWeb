//pimera parte del codigo
public async Task<Game> ExecuteAsync(string connectionId, string playerUid)
{
    var playerProfile = await _playerRepository.GetByUidAsync(playerUid);
    if (playerProfile == null)
    {
        throw new NotFoundException("Perfil de jugador no encontrado");
    }

    _logger.LogInformation($"üîç Matchmaking para {playerProfile.Name} (UID: {playerUid}, Puntos: {playerProfile.Points})");

    // PRIMERO: Buscar partidas esperando jugadores ANTES de crear el objeto Player
    var waitingGames = await _gameRepository.GetWaitingGamesAsync();
    
    _logger.LogInformation($"üìã Encontradas {waitingGames.Count} partidas esperando jugadores");
    
    // Verificar si el jugador ya est√° en alguna partida
    var existingGame = waitingGames.FirstOrDefault(g => 
        g.Players.Any(p => p.Uid == playerUid));

    if (existingGame != null)
    {
        _logger.LogInformation($"‚úÖ Jugador ya est√° en la partida {existingGame.Id}. Reconectando...");
        
        var existingPlayer = existingGame.Players.First(p => p.Uid == playerUid);
        existingPlayer.ConnectionId = connectionId;
        
        await _gameRepository.UpdateAsync(existingGame);
        return existingGame;
    }

    // Calcular tolerancia
    var toleranceRange = CalculateToleranceRange(playerProfile.Points);
    _logger.LogInformation($"üìä Tolerancia de matchmaking: ¬±{toleranceRange} puntos");

    // Buscar partida compatible EN LA LISTA YA OBTENIDA
    Game? compatibleGame = null;
    
    foreach (var game in waitingGames)
    {
        var existingPlayer = game.Players.First();
        var existingPlayerProfile = await GetPlayerProfileByUid(existingPlayer.Uid);
        
        if (existingPlayerProfile != null)
        {
            var pointsDifference = Math.Abs(playerProfile.Points - existingPlayerProfile.Points);
            
            _logger.LogInformation(
                $"üîé Evaluando partida {game.Id} - {existingPlayer.Name} " +
                $"(Diferencia: {pointsDifference}, Tolerancia: {toleranceRange})");
            
            if (pointsDifference <= toleranceRange)
            {
                compatibleGame = game;
                _logger.LogInformation($"‚úÖ Partida compatible encontrada: {game.Id}");
                break;
            }
        }
    }

    // Crear el Player object SOLO despu√©s de verificar que no hay partida compatible
    var player = new Player 
    { 
        Id = Interlocked.Increment(ref _nextPlayerId),
        Name = playerProfile.Name,
        Uid = playerUid,
        ConnectionId = connectionId
    };

    player.AvailablePowerUps = _powerUpService.GrantInitialPowerUps(player.Id);

    if (compatibleGame != null)
    {
        // Unirse a partida compatible
        compatibleGame.Players.Add(player);
        
        if (compatibleGame.Players.Count == 2)
        {
            compatibleGame.Status = GameStatus.InProgress;
            _logger.LogInformation($"üéÆ Partida {compatibleGame.Id} iniciada con 2 jugadores");
        }

        await _gameRepository.UpdateAsync(compatibleGame);
        return compatibleGame;
    }
    else
    {
        // Crear nueva partida
        _logger.LogInformation($"üÜï No se encontr√≥ partida compatible. Creando nueva partida...");
        return await CreateNewMatchmakingGameAsync(player, playerProfile.Points);
    }
}




// IGameRepository.cs
public interface IGameRepository
{
    // ... otros m√©todos ...
    Task<List<Game>> GetWaitingGamesAsync();
}

// GameRepository.cs (o el nombre que uses)
public class GameRepository : IGameRepository
{
    private readonly ApplicationDbContext _context;
    private static readonly SemaphoreSlim _matchmakingLock = new SemaphoreSlim(1, 1);

    public async Task<List<Game>> GetWaitingGamesAsync()
    {
        return await _context.Games
            .Include(g => g.Players)  // IMPORTANTE: Incluir jugadores
            .Where(g => g.Status == GameStatus.WaitingForPlayers && 
                        g.Players.Count == 1)
            .OrderBy(g => g.CreatedAt)
            .AsNoTracking()  // Evitar problemas de tracking
            .ToListAsync();
    }
    
    public async Task<Game?> GetByIdWithPlayersAsync(int gameId)
    {
        return await _context.Games
            .Include(g => g.Players)
            .FirstOrDefaultAsync(g => g.Id == gameId);
    }
}

back del use case que maneja el matchmaking
public class FindMatchWithMatchmakingUseCase
{
    private static readonly SemaphoreSlim _matchmakingLock = new SemaphoreSlim(1, 1);
    // ... resto de los campos ...

    public async Task<Game> ExecuteAsync(string connectionId, string playerUid)
    {
        // LOCK: Solo un jugador puede buscar/crear partida a la vez
        await _matchmakingLock.WaitAsync();
        
        try
        {
            return await ExecuteMatchmakingAsync(connectionId, playerUid);
        }
        finally
        {
            _matchmakingLock.Release();
        }
    }

    private async Task<Game> ExecuteMatchmakingAsync(string connectionId, string playerUid)
    {
        var playerProfile = await _playerRepository.GetByUidAsync(playerUid);
        if (playerProfile == null)
        {
            throw new NotFoundException("Perfil de jugador no encontrado");
        }

        _logger.LogInformation($"üîç Matchmaking para {playerProfile.Name} (UID: {playerUid}, Puntos: {playerProfile.Points})");

        // Buscar partidas esperando jugadores
        var waitingGames = await _gameRepository.GetWaitingGamesAsync();
        
        _logger.LogInformation($"üìã Encontradas {waitingGames.Count} partidas esperando jugadores");

        // Verificar si el jugador ya est√° en alguna partida
        var existingGame = waitingGames.FirstOrDefault(g => 
            g.Players.Any(p => p.Uid == playerUid));

        if (existingGame != null)
        {
            _logger.LogInformation($"‚úÖ Jugador ya est√° en la partida {existingGame.Id}");
            
            // Recargar la partida con tracking para poder modificarla
            var trackedGame = await _gameRepository.GetByIdWithPlayersAsync(existingGame.Id);
            if (trackedGame != null)
            {
                var existingPlayer = trackedGame.Players.First(p => p.Uid == playerUid);
                existingPlayer.ConnectionId = connectionId;
                await _gameRepository.UpdateAsync(trackedGame);
                return trackedGame;
            }
            return existingGame;
        }

        // Calcular tolerancia
        var toleranceRange = CalculateToleranceRange(playerProfile.Points);
        _logger.LogInformation($"üìä Tolerancia: ¬±{toleranceRange} puntos");

        // Buscar partida compatible
        Game? compatibleGame = null;
        
        foreach (var game in waitingGames)
        {
            var existingPlayer = game.Players.First();
            
            _logger.LogInformation($"üîé Evaluando partida {game.Id} - Jugador: {existingPlayer.Name} (UID: {existingPlayer.Uid})");
            
            var existingPlayerProfile = await GetPlayerProfileByUid(existingPlayer.Uid);
            
            if (existingPlayerProfile != null)
            {
                var pointsDifference = Math.Abs(playerProfile.Points - existingPlayerProfile.Points);
                
                _logger.LogInformation($"üìä Diferencia: {pointsDifference} puntos (Tolerancia: {toleranceRange})");
                
                if (pointsDifference <= toleranceRange)
                {
                    compatibleGame = game;
                    _logger.LogInformation($"‚úÖ Partida {game.Id} es compatible!");
                    break;
                }
            }
        }

        // Crear Player
        var player = new Player 
        { 
            Id = Interlocked.Increment(ref _nextPlayerId),
            Name = playerProfile.Name,
            Uid = playerUid,
            ConnectionId = connectionId
        };

        player.AvailablePowerUps = _powerUpService.GrantInitialPowerUps(player.Id);

        if (compatibleGame != null)
        {
            // Recargar con tracking para poder modificar
            var trackedGame = await _gameRepository.GetByIdWithPlayersAsync(compatibleGame.Id);
            
            if (trackedGame == null)
            {
                _logger.LogWarning($"‚ö†Ô∏è No se pudo recargar la partida {compatibleGame.Id}, creando nueva");
                return await CreateNewMatchmakingGameAsync(player, playerProfile.Points);
            }

            // Verificar nuevamente que no est√© llena (otro jugador pudo unirse mientras tanto)
            if (trackedGame.Players.Count >= 2)
            {
                _logger.LogWarning($"‚ö†Ô∏è Partida {trackedGame.Id} ya est√° llena, creando nueva");
                return await CreateNewMatchmakingGameAsync(player, playerProfile.Points);
            }

            trackedGame.Players.Add(player);
            
            if (trackedGame.Players.Count == 2)
            {
                trackedGame.Status = GameStatus.InProgress;
                _logger.LogInformation($"üéÆ Partida {trackedGame.Id} iniciada con 2 jugadores");
            }

            await _gameRepository.UpdateAsync(trackedGame);
            return trackedGame;
        }
        else
        {
            _logger.LogInformation($"üÜï Creando nueva partida...");
            return await CreateNewMatchmakingGameAsync(player, playerProfile.Points);
        }
    }

    // ... resto de los m√©todos (CalculateToleranceRange, GetPlayerProfileByUid, CreateNewMatchmakingGameAsync) ...
}
// explicacion 
Cambios clave:

‚úÖ SemaphoreSlim: Lock para evitar que dos jugadores creen partidas simult√°neamente
‚úÖ AsNoTracking(): Evita conflictos de tracking en Entity Framework
‚úÖ GetByIdWithPlayersAsync(): Recarga la entidad con tracking para poder modificarla
‚úÖ Verificaci√≥n doble: Antes de unirse, verifica que la partida no se haya llenado
‚úÖ Logs detallados: Para debugging completo
Esto deber√≠a resolver el problema de partidas duplicadas